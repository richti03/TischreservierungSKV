<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Saalplan – Weißes Layout (Fixe Zeichenfläche)</title>
    <style>
        :root {
            --line: #111;
            --muted: #666;
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            font-family: system-ui, sans-serif;
            background: #fff;
            color: #111
        }

        .frame {

            height: 100%;
            border: 2px solid var(--line);
            margin: 24px auto;
            padding: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background: #fff;
        }

        h1 {
            margin: 0;
            text-align: center;
            font-size: 20px
        }

        .main-area {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            justify-content: center;
            gap: 40px;
            margin-bottom: 10px; /* weniger Abstand nach unten */
        }

        .col {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
            justify-content: center
        }

        .parkett-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .parkett {
            width: 220px;
            height: 240px;
            border: 2px solid var(--line);
            display: grid;
            place-items: center;
        }

        .bottom-row {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            gap: 6px;
            padding: 0 40px; /* enger am Parkett */
        }

        .table {
            position: relative;
            background: #fff;
            border: 2px solid var(--line);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .label {
            font-size: 11px;
            color: var(--muted);
            white-space: nowrap;
        }

        .label.vertical {
            transform: rotate(-90deg);
            white-space: nowrap;
        }

        .label[role="button"],
        .standing[role="button"] {
            cursor: pointer;
        }

        .label[role="button"]:focus-visible,
        .standing[role="button"]:focus-visible {
            outline: 2px solid var(--line);
            outline-offset: 2px;
        }

        .chair {
            position: absolute;
            width: 12px;
            height: 12px;
            border: 1px solid var(--line);
            background: #fff;
            border-radius: 2px;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            cursor: default;
        }

        .chair:hover {
            transform: scale(1.2);
            box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.15);
        }

        .chair--free {
            background: #fff;
        }

        .chair--sold {
            background: #111;
            border-color: #000;
        }

        .chair--reserved {
            border-color: rgba(0, 0, 0, 0.55);
        }

        .side-top {
            top: -8px
        }

        .side-bottom {
            bottom: -8px
        }

        .side-left {
            left: -8px
        }

        .side-right {
            right: -8px
        }
    </style>
</head>
<body>
<div class="frame">
    <h1>Saalplan</h1>

    <div class="main-area">
        <div class="col" id="leftCol"></div>
        <div class="parkett-wrapper">
            <div class="parkett" id="parkett">
                <p>PARKETT</p>
                <div class="standing" id="standing">
                    <p>Stehplätze</p>
                    <p>0/76</p>
                </div>
            </div>
        </div>
        <div class="col" id="rightCol"></div>
    </div>

    <div class="bottom-row" id="bottomRow"></div>
</div>

<script>
    const CHANNEL_NAME = "skv-internal-plan";
    const STORAGE_KEY = "skv-internal-plan-message";
    const MESSAGE_MARKER = "__skvInternalPlan";
    const MAX_SEEN_MESSAGES = 200;

    const leftCol = document.getElementById('leftCol');
    const rightCol = document.getElementById('rightCol');
    const bottomRow = document.getElementById('bottomRow');
    const standingEl = document.getElementById('standing');
    const frame = document.querySelector('.frame');

    const COLOR_PRESETS = {
        red: {primary: '#E53935'},
        blue: {primary: '#1E88E5'},
        yellow: {primary: '#FDD835'},
        orange: {primary: '#FB8C00'},
        purple: {primary: '#8E24AA'},
        green: {primary: '#43A047'},
        gray: {primary: '#757575'},
    };

    const EVEN_TABLE_COLOR_SEQUENCE = [
        COLOR_PRESETS.red,
        COLOR_PRESETS.blue,
        COLOR_PRESETS.yellow,
        COLOR_PRESETS.orange,
        COLOR_PRESETS.purple,
        COLOR_PRESETS.green,
        COLOR_PRESETS.gray,
    ];

    const ODD_TABLE_COLOR_SEQUENCE = [
        COLOR_PRESETS.orange,
        COLOR_PRESETS.purple,
        COLOR_PRESETS.green,
        COLOR_PRESETS.red,
        COLOR_PRESETS.blue,
        COLOR_PRESETS.yellow,
        COLOR_PRESETS.gray,
    ];

    function parseTableNumber(tableNr) {
        if (Number.isInteger(tableNr)) {
            return tableNr;
        }

        if (typeof tableNr === 'string') {
            const trimmed = tableNr.trim();
            if (!trimmed) return null;

            const direct = Number(trimmed);
            if (Number.isInteger(direct)) {
                return direct;
            }

            const match = trimmed.match(/-?\d+/);
            if (match) {
                const parsed = Number(match[0]);
                if (Number.isInteger(parsed)) {
                    return parsed;
                }
            }
        }

        return null;
    }

    function getColorSequenceForTable(tableNr) {
        const nr = parseTableNumber(tableNr);
        if (!Number.isInteger(nr)) {
            return EVEN_TABLE_COLOR_SEQUENCE;
        }
        return Math.abs(nr) % 2 === 0 ? EVEN_TABLE_COLOR_SEQUENCE : ODD_TABLE_COLOR_SEQUENCE;
    }

    function applyTablePalette(table, segments) {
        const paletteSequence = getColorSequenceForTable(table?.nr);
        let paletteIndex = 0;
        return segments.map(segment => {
            if (!segment || segment.type !== 'reserved') {
                return segment;
            }
            const palette = paletteSequence[paletteIndex % paletteSequence.length];
            paletteIndex += 1;
            return {
                ...segment,
                colorPrimary: palette.primary,
                colorSecondary: palette.secondary,
            };
        });
    }

    function rememberMessageId(id) {
        if (!id || seenMessageIds.has(id)) return;
        seenMessageIds.add(id);
        seenMessageQueue.push(id);
        if (seenMessageQueue.length > MAX_SEEN_MESSAGES) {
            const oldest = seenMessageQueue.shift();
            if (oldest !== undefined) {
                seenMessageIds.delete(oldest);
            }
        }
    }

    function hasSeenMessage(id) {
        if (!id) return false;
        return seenMessageIds.has(id);
    }

    function createEnvelope(data) {
        return {
            marker: MESSAGE_MARKER,
            id: `${Date.now()}-${Math.random().toString(16).slice(2)}`,
            data,
        };
    }

    function transmitEnvelope(envelope) {
        const bc = ensureChannel();
        if (bc && envelope) {
            try {
                bc.postMessage(envelope);
            } catch (err) {
                console.warn('[SYNC] BroadcastChannel konnte Nachricht nicht senden:', err);
            }
        }

        if (!envelope) return;

        if (typeof localStorage === 'undefined' || localStorage === null) {
            return;
        }

        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(envelope));
        } catch (err) {
            if (err?.name !== 'SecurityError') {
                console.warn('[SYNC] localStorage-Fallback konnte Nachricht nicht senden:', err);
            }
        }
    }

    function sendInternalMessage(data) {
        transmitEnvelope(createEnvelope(data));
    }

    function notifyTableSelection(tableNr) {
        const nr = parseTableNumber(tableNr);
        if (!Number.isInteger(nr)) return;
        sendInternalMessage({type: 'select-table', tableNr: nr});
    }

    function isActivationKey(event) {
        return event.key === 'Enter' || event.key === ' ' || event.key === 'Spacebar';
    }

    if (standingEl) {
        standingEl.setAttribute('role', 'button');
        standingEl.tabIndex = 0;
        standingEl.addEventListener('click', event => {
            event.preventDefault();
            notifyTableSelection(0);
        });
        standingEl.addEventListener('keydown', event => {
            if (!isActivationKey(event)) return;
            event.preventDefault();
            notifyTableSelection(0);
        });
    }

    const TABLE_THICKNESS = 32;
    const PX_PER_SEAT = 7.5;
    const PARKETT_WIDTH = 220;
    const FRAME_EXTRA_WIDTH = 100;

    let channel = null;
    let storageListenerBound = false;
    const seenMessageIds = new Set();
    const seenMessageQueue = [];

    function setupStorageListener() {
        if (storageListenerBound) return;
        if (typeof window === 'undefined' || typeof window.addEventListener !== 'function') return;
        window.addEventListener('storage', onStorageMessage);
        storageListenerBound = true;
    }

    function ensureChannel() {
        setupStorageListener()
        if (!('BroadcastChannel' in window)) {
            return null;
        }
        if (!channel) {
            try {
                channel = new BroadcastChannel(CHANNEL_NAME);
                channel.addEventListener('message', onChannelMessage);
                window.addEventListener('beforeunload', () => {
                    try {
                        channel?.close();
                    } catch (err) {
                        console.warn('[SYNC] Kanal konnte nicht geschlossen werden:', err);
                    }
                }, {once: true});
            } catch (err) {
                console.warn('[SYNC] BroadcastChannel konnte nicht initialisiert werden:', err);
                channel = null;
            }
        }
        return channel;
    }

    function handleIncomingPayload(payload) {
        if (!payload || typeof payload !== 'object') return;
        if (payload.type === 'state' && payload.payload) {
            renderPlan(payload.payload);
        }
    }

    function handleEnvelope(envelope) {
        if (!envelope || envelope.marker !== MESSAGE_MARKER) return;
        if (hasSeenMessage(envelope.id)) return;
        rememberMessageId(envelope.id);
        handleIncomingPayload(envelope.data);
    }

    function onChannelMessage(event) {
        handleEnvelope(event?.data);
    }

    function onStorageMessage(event) {
        if (!event || event.key !== STORAGE_KEY) return;
        if (!event.newValue) return;
        try {
            const parsed = JSON.parse(event.newValue);
            handleEnvelope(parsed);
        } catch (err) {
            console.warn('[SYNC] Konnte Nachricht aus localStorage nicht verarbeiten:', err);
        }
    }

    function clearChildren(el) {
        if (!el) return;
        while (el.firstChild) el.removeChild(el.firstChild);
    }

    function getHorizontalLength(table) {
        const totalSeats = Math.max(parseInt(table?.total, 10) || 0, 0);
        return totalSeats * PX_PER_SEAT;
    }

    function buildSeatTitle(segment, seatIndex) {
        if (!segment || segment.type === 'free') return 'Frei';
        const seatCount = Math.max(parseInt(segment.count, 10) || 0, 0);
        const parts = [];

        if (segment.name) {
            parts.push(segment.name);
        } else {
            const typeLabel = segment.type === 'sold' ? 'Verkauft' : 'Reserviert';
            parts.push(typeLabel);
        }

        if (seatCount > 0) {
            const seatNumber = Math.min(seatIndex + 1, seatCount);
            parts.push(`Platz ${seatNumber} von ${seatCount}`);
        }

        if (segment.splitInfo) {
            parts.push(segment.splitInfo);
        }

        return parts.join(' · ');
    }

    function expandSegmentsToSeats(table, totalSeats) {
        const seats = [];
        const baseSegments = Array.isArray(table?.segments) ? table.segments : [];
        const segments = applyTablePalette(table, baseSegments);
        segments.forEach(segment => {
            const count = Math.max(parseInt(segment?.count, 10) || 0, 0);
            if (!count) return;
            for (let i = 0; i < count; i++) {
                const seat = {
                    type: segment.type === 'sold' ? 'sold' : (segment.type === 'reserved' ? 'reserved' : 'free'),
                    bookingId: segment.bookingId || null,
                    name: segment.name || '',
                    title: buildSeatTitle(segment, i),
                    colorPrimary: segment.colorPrimary || null,
                    notes: segment.notes || '',
                };
                if (seat.type === 'reserved') {
                    const color = seat.colorPrimary || '#c5e1a5';
                    seat.background = color;
                    seat.borderColor = color;
                } else if (seat.type === 'sold') {
                    seat.background = '#111';
                    seat.borderColor = '#000';
                } else {
                    seat.background = '#fff';
                    seat.borderColor = 'var(--line)';
                }
                seats.push(seat);
            }
        });

        while (seats.length < totalSeats) {
            seats.push({
                type: 'free',
                title: 'Frei',
                background: '#fff',
                borderColor: 'var(--line)'
            });
        }

        if (seats.length > totalSeats) seats.length = totalSeats;

        return seats;
    }

    function applySeatVisual(chair, seat) {
        const state = seat?.type || 'free';
        chair.dataset.state = state;
        chair.classList.add('chair--' + state);
        if (seat?.bookingId) chair.dataset.bookingId = seat.bookingId;
        chair.title = seat?.title || (state === 'sold' ? 'Verkauft' : state === 'reserved' ? 'Reserviert' : 'Frei');
        if (seat?.background) chair.style.background = seat.background;
        if (seat?.borderColor) chair.style.borderColor = seat.borderColor;
    }

    function makeTableEl(table, orientation) {
        const length = getHorizontalLength(table);
        const thickness = TABLE_THICKNESS;
        const totalSeats = Math.max(parseInt(table?.total, 10) || 0, 0);
        const seats = expandSegmentsToSeats(table, totalSeats);

        const el = document.createElement('div');
        if (orientation === 'horizontal') {
            el.style.width = length + 'px';
            el.style.height = thickness + 'px';
        } else {
            el.style.width = thickness + 'px';
            el.style.height = length + 'px';
        }
        el.className = `table ${orientation}`;
        el.dataset.table = table.nr;

        const titleParts = [`Tisch ${table.nr}`];
        titleParts.push(`Frei: ${table.free}`);
        titleParts.push(`Reserviert: ${table.reserved}`);
        if (table.sold) titleParts.push(`Verkauft: ${table.sold}`);
        el.title = titleParts.join(' · ');

        const label = document.createElement('div');
        label.className = 'label';
        label.textContent = 'Tisch ' + table.nr + ': ' + totalSeats + ' Plätze';
        label.dataset.tableNr = table.nr;
        label.setAttribute('role', 'button');
        label.tabIndex = 0;
        label.addEventListener('click', event => {
            event.preventDefault();
            notifyTableSelection(table.nr);
        });
        label.addEventListener('keydown', event => {
            if (!isActivationKey(event)) return;
            event.preventDefault();
            notifyTableSelection(table.nr);
        });
        if (orientation === 'vertical') label.classList.add('vertical');
        el.appendChild(label);

        if (totalSeats > 0) {
            const isHorizontal = orientation === 'horizontal';
            const longSide = length;
            const makeOffsets = count => {
                if (count <= 0) return [];
                if (count === 1) return [Math.max((longSide - 12) / 2, 0)];
                const usable = Math.max(longSide - 12, 0);
                const span = usable / (count - 1);
                return Array.from({length: count}, (_, i) => i * span);
            };

            const sideA = Math.ceil(totalSeats / 2);
            const sideB = totalSeats - sideA;
            const offsetsA = makeOffsets(sideA);
            const offsetsB = makeOffsets(sideB);

            const createChair = (className, offset, seat) => {
                const chair = document.createElement('div');
                chair.className = 'chair ' + className;
                if (isHorizontal) {
                    chair.style.left = offset + 'px';
                } else {
                    chair.style.top = offset + 'px';
                }
                applySeatVisual(chair, seat);
                return chair;
            };

            offsetsA.forEach((offset, idx) => {
                const cls = isHorizontal ? 'side-top' : 'side-left';
                el.appendChild(createChair(cls, offset, seats[idx]));
            });

            offsetsB.forEach((offset, idx) => {
                const cls = isHorizontal ? 'side-bottom' : 'side-right';
                const seat = seats[sideA + idx];
                el.appendChild(createChair(cls, offset, seat));
            });
        }

        return el;
    }

    // Hilfsfunktion: optionalen Gang (breiteren Abstand) neben einem Tisch setzen
    function applyGangDaneben(el, where) {
        const EXTRA = 40; // px – bei Bedarf anpassen
        if (!el || !where) return;
        switch (where) {
            case 'oben':
                el.style.marginTop = EXTRA + 'px';
                break;

            case 'unten':
                el.style.marginBottom = EXTRA + 'px';
                break;
            case 'links':
                el.style.marginLeft = EXTRA + 'px';
                break;
            case 'rechts':
                el.style.marginRight = EXTRA + 'px';
                break;
        }
    }

    function updateStandingInfo(table) {
        if (!standingEl) return;
        const lines = standingEl.querySelectorAll('p');
        if (!table) {
            if (lines[1]) lines[1].textContent = '0/0';
            standingEl.removeAttribute('title');
            return;
        }
        const reserved = `${table.reserved}/${table.total}`;
        if (lines[1]) lines[1].textContent = reserved;
        else {
            const p = document.createElement('p');
            p.textContent = reserved;
            standingEl.appendChild(p);
        }
        const parts = [`Frei: ${table.free}`, `Reserviert: ${table.reserved}`];
        if (table.sold) parts.push(`Verkauft: ${table.sold}`);
        standingEl.title = parts.join(' · ');
    }

    function renderPlan(payload) {
        const tables = Array.isArray(payload?.tables) ? payload.tables : [];
        const leftTables = tables.filter(t => t.position === 'left').sort((a, b) => a.nr - b.nr);
        const rightTables = tables.filter(t => t.position === 'right').sort((a, b) => a.nr - b.nr);
        const bottomTables = tables.filter(t => !['left', 'right', 'standing'].includes(t.position)).sort((a, b) => a.nr - b.nr);
        const standingTable = tables.find(t => t.position === 'standing');

        if (frame) {
            const longestLeft = leftTables.length ? Math.max(...leftTables.map(getHorizontalLength)) : 0;
            const longestRight = rightTables.length ? Math.max(...rightTables.map(getHorizontalLength)) : 0;
            const computedWidth = longestLeft + longestRight + PARKETT_WIDTH + FRAME_EXTRA_WIDTH;
            frame.style.width = computedWidth + 'px';
        }

        clearChildren(leftCol);
        leftTables.forEach(cfg => {
            const el = makeTableEl(cfg, 'horizontal');
            if (cfg.gangDaneben) applyGangDaneben(el, cfg.gangDaneben);
            leftCol?.appendChild(el);
        });

        clearChildren(bottomRow);
        bottomTables.forEach(cfg => {
            const el = makeTableEl(cfg, 'vertical');
            if (cfg.gangDaneben) applyGangDaneben(el, cfg.gangDaneben);
            bottomRow?.appendChild(el);
        });

        clearChildren(rightCol);
        if (rightCol) {
            rightCol.style.display = 'flex';
            rightCol.style.flexDirection = 'column-reverse';
            rightTables.forEach(cfg => {
                const el = makeTableEl(cfg, 'horizontal');
                if (cfg.gangDaneben) applyGangDaneben(el, cfg.gangDaneben);
                rightCol.appendChild(el);
            });
        }


        updateStandingInfo(standingTable);
    }

    ensureChannel();
    sendInternalMessage({type: 'request_state'});
</script>
</body>
</html>
